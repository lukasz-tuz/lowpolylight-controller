esphome:
  name: lowpoly-butterfly

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:

# Enable Home Assistant API
api:

ota:
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Lowpoly-Butterfly"
    password: "SsBQuDL3bOYV"

captive_portal:

light:
  - platform: neopixelbus
    type: GRB
    variant: WS2813
    pin: GPIO22
    num_leds: 66
    name: "Lowpoly Butterfly"
    id: lowpoly
    effects:
      - random:
          name: "Random"
      - addressable_rainbow:
          name: "Rainbow"
          speed: 10
          width: 66
      - addressable_twinkle:
          name: "Twinkle"
      - addressable_lambda:
          name: "Voronoi"
          update_interval: 1ms
          lambda: |-
            // Time, in miliseconds, needed for each segment to transition to new random color
            static const uint16_t segtrans = 1000;

            // Number of segments
            static const uint8_t nsegments = 9;

            // End indices for each segment
            static const uint8_t ranges[nsegments] = {7, 14, 20, 33, 36, 50, 54, 59, 65};

            // Base, starting color
            static const uint8_t base_color = 191;
            
            // Number of steps in each transition
            static const uint16_t steps = segtrans / 1;

            static uint16_t progress = 1;
            
            static uint8_t start_colors[nsegments] = {base_color};
            static uint8_t target_colors[nsegments] = {0};

            static float segcolors[nsegments] = {0};

            if (initial_run || progress == steps) {
              // Generate random new target color for each segment
              random_bytes(target_colors, nsegments);
              progress = 1;
            }          

            uint8_t start = 0;
            uint8_t end = 0;

            for(uint8_t ii = 0; ii < nsegments; ii++) {
              end = ranges[ii] + 1;
              float k = (float)(target_colors[ii] - start_colors[ii]) / (float)steps;
              segcolors[ii] = start_colors[ii] + k * progress;
              it.range(start, end) = Color(240, (uint8_t)segcolors[ii], 10);
              start = end;
            }
            progress++;

            if (progress == steps) {
              memcpy(start_colors, target_colors, nsegments);
            }

            return;

esp32_touch:
  setup_mode: false

binary_sensor:
  - platform: esp32_touch
    name: "Power switch"
    pin: GPIO33
    threshold: 450
    on_release:
      then:
        lambda: |-
            auto call = id(lowpoly).turn_on();

            auto effects = id(lowpoly).get_effects();
            std::string name = id(lowpoly).get_effect_name();

            uint8_t i = 0;

            if (name != "None") {
              // There's an effect in progress, move to the next one
              for (auto e : effects) {
                i++;
                if (e->get_name() == name) {
                  break;
                }
              }
            }
            else {
              i = 0;
            }
            if (i >= effects.size()) {
              call.set_effect("None");
            } else {
              call.set_effect(effects[i]->get_name());
            }
            call.perform();
            return;
