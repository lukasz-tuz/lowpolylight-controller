esphome:
  name: lowpoly-butterfly

esp32:
  board: esp32dev
  framework:
    type: arduino

substitutions:
  wing_led_count: '66'
  segment_length: '65'
  light_led_count: '131'


# Enable logging
logger:

# Enable Home Assistant API
api:

ota:
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Lowpoly-Butterfly"
    password: "SsBQuDL3bOYV"

captive_portal:

web_server:
  port: 80

switch:
  - platform: restart
    name: "Restart Light"

# esp32_improv:
#   authorizer: none

light:
  - platform: partition
    name: "Lowpoly Butterfly"
    id: lowpoly
    segments:
      - id: right_wing
        from: 0
        to: ${segment_length}
      - id: left_wing
        from: 0
        to: ${segment_length}
    effects:
      - random:
          name: "Random"
      - addressable_rainbow:
          name: "Rainbow"
          width: ${wing_led_count}
      - addressable_twinkle:
          name: "Twinkle"
      - addressable_lambda:
          name: "Voronoi"
          update_interval: 1ms
          lambda: |-
            // Time, in miliseconds, needed for each segment to transition to new random color
            static const uint16_t segtrans = 200;

            // Number of segments
            static const uint8_t nsegments = 18;

            // End indices for each segment
            static const uint8_t ranges[nsegments] = {8, 15, 21, 34, 37, 51, 55, 60, 66, \
                                                      73, 80, 86, 99, 102, 116, 120, 125, 131};

            // Number of steps in each transition
            static const uint16_t steps = segtrans / 1;

            static uint16_t progress = 1;

            // Base, starting color
            static uint8_t start_colors[nsegments] = {127};
            static uint8_t target_colors[nsegments] = {0};

            static float segcolors[nsegments] = {0};

            if (initial_run || progress == steps) {
              // Generate random new target color for each segment
              random_bytes(target_colors, nsegments);
              // Clip values
              for (uint8_t ii = 0; ii < nsegments; ii++) {
                target_colors[ii] = min(target_colors[ii], (uint8_t)164);
              }
              progress = 1;
            }

            uint8_t start = 0;
            uint8_t end = 0;

            for(uint8_t ii = 0; ii < nsegments; ii++) {
              end = ranges[ii] + 1;
              float k = (float)(target_colors[ii] - start_colors[ii]) / (float)steps;
              segcolors[ii] = start_colors[ii] + k * progress;
              it.range(start, end) = Color(220, (uint8_t)segcolors[ii], 0);
              start = end;
            }
            progress++;

            if (progress == steps) {
              memcpy(start_colors, target_colors, nsegments);
            }

            return;

  - platform: fastled_clockless
    rgb_order: GRB
    chipset: WS2813
    pin: GPIO22
    num_leds: ${wing_led_count}
    name: "Right Wing"
    id: right_wing
    internal: true

  - platform: neopixelbus
    type: GRB
    variant: WS2813
    pin: GPIO23
    num_leds: ${wing_led_count}
    name: "Left Wing"
    id: left_wing
    internal: true

# esp32_touch:
#   setup_mode: true

# binary_sensor:
#   - platform: esp32_touch
#     name: "On/Off"
#     pin: GPIO32
#     threshold: 450
#     on_release:
#       then:
#         - light.toggle:
#             id: lowpoly

#   - platform: esp32_touch
#     name: "Toggle Effect"
#     pin: GPIO33
#     threshold: 450
#     on_release:
#       then:
#         lambda: |-
#             auto call = id(lowpoly).turn_on();

#             auto effects = id(lowpoly).get_effects();
#             std::string name = id(lowpoly).get_effect_name();

#             uint8_t i = 0;

#             if (name != "None") {
#               // There's an effect in progress, move to the next one
#               for (auto e : effects) {
#                 i++;
#                 if (e->get_name() == name) {
#                   break;
#                 }
#               }
#             }
#             else {
#               i = 0;
#             }
#             if (i >= effects.size()) {
#               call.set_effect("None");
#             } else {
#               call.set_effect(effects[i]->get_name());
#             }
#             call.perform();
#             return;
