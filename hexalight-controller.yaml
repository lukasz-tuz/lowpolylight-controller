esphome:
  name: lowpoly-butterfly

esp32:
  board: esp32dev
  framework:
    type: arduino

substitutions:
  num_leds: '66'
  max_led_idx: '65'

# Enable logging
logger:

# Enable Home Assistant API
api:

ota:
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Lowpoly-Butterfly"
    password: "SsBQuDL3bOYV"

captive_portal:

web_server:
  port: 80

switch:
  - platform: restart
    name: "Restart Light"

# esp32_improv:
#   authorizer: none

light:
  - platform: partition
    name: "Lowpoly Butterfly"
    id: lowpoly
    segments:
      - id: right_wing
        from: 0
        to: ${max_led_idx}
      - id: left_wing
        from: 0
        to: ${max_led_idx}
    effects:
      - random:
          name: "Random"
      - addressable_rainbow:
          name: "Rainbow"
          width: ${num_leds}
      - addressable_twinkle:
          name: "Twinkle"
      - addressable_lambda:
          name: "Voronoi"
          update_interval: 1ms
          lambda: |-
            // Time, in miliseconds, needed for each segment to transition to new random color
            static const uint16_t segtrans = 200;

            // Number of segments
            static const uint8_t nsegments = 18;

            // End indices for each segment
            static const uint8_t ranges[nsegments] = {7, 14, 20, 33, 36, 50, 54, 59, 65, \
                                                      72, 79, 85, 98, 101, 115, 119, 124, 131};

            // Number of steps in each transition
            static const uint16_t steps = segtrans / 1;

            static uint16_t progress = 1;

            // Base, starting color
            static uint8_t start_colors[nsegments] = {127};
            static uint8_t target_colors[nsegments] = {0};

            static float segcolors[nsegments] = {0};

            if (initial_run || progress == steps) {
              // Generate random new target color for each segment
              random_bytes(target_colors, nsegments);
              // Clip values
              for (uint8_t ii = 0; ii < nsegments; ii++) {
                target_colors[ii] = min(target_colors[ii], (uint8_t)164);
              }
              progress = 1;
            }

            uint8_t start = 0;
            uint8_t end = 0;

            for(uint8_t ii = 0; ii < nsegments; ii++) {
              end = ranges[ii] + 1;
              float k = (float)(target_colors[ii] - start_colors[ii]) / (float)steps;
              segcolors[ii] = start_colors[ii] + k * progress;
              it.range(start, end) = Color(220, (uint8_t)segcolors[ii], 0);
              start = end;
            }
            progress++;

            if (progress == steps) {
              memcpy(start_colors, target_colors, nsegments);
            }

            return;

  - platform: fastled_clockless
    rgb_order: GRB
    chipset: WS2813
    pin: GPIO22
    num_leds: ${num_leds}
    name: "Right Wing"
    id: right_wing
    internal: true

  - platform: neopixelbus
    type: GRB
    variant: WS2813
    pin: GPIO23
    num_leds: ${num_leds}
    name: "Left Wing"
    id: left_wing
    internal: true

esp32_touch:
  setup_mode: true
  iir_filter: 15ms
  low_voltage_reference: 0.5V
  high_voltage_reference: 2.7V
  voltage_attenuation: 1.5V

binary_sensor:
  - platform: esp32_touch
    name: "On/Off"
    pin: GPIO32
    threshold: 1200
    on_release:
      then:
        - light.toggle:
            id: lowpoly

  - platform: esp32_touch
    name: "Toggle Effect"
    pin: GPIO33
    threshold: 1200
    on_release:
      then:
        lambda: |-
            auto call = id(lowpoly).turn_on();

            auto effects = id(lowpoly).get_effects();
            std::string name = id(lowpoly).get_effect_name();

            uint8_t i = 0;

            if (name != "None") {
              // There's an effect in progress, move to the next one
              for (auto e : effects) {
                i++;
                if (e->get_name() == name) {
                  break;
                }
              }
            }
            else {
              i = 0;
            }
            if (i >= effects.size()) {
              call.set_effect("None");
            } else {
              call.set_effect(effects[i]->get_name());
            }
            call.perform();
            return;
